from __future__ import annotations

from palimpzest.operators import LogicalOperator, FilteredScan
from palimpzest.operators.physical import PhysicalOperator
from palimpzest.sets import Set

from typing import Any, Dict, List, Optional


class Plan:
    """A generic Plan is a graph of nodes (#TODO a list for now).
    The main subclasses are a LogicalPlan, which is composed of logical Operators, and a PhysicalPlan, which is composed of physical Operators.
    Plans are typically generated by objects of class Planner, and consumed by several objects, e.g., Execution, CostEstimator, Optimizer, etc. etc.
    """

    operators = []

    def __init__(self):
        raise NotImplementedError

    def __iter__(self):
        return iter(self.operators)

    def __next__(self):
        return next(iter(self.operators))

    def __len__(self):
        return len(self.operators)

    def __repr__(self):
        return f"{self.__class__.__name__}:\n" + "\n".join(
            map(str, [f"{idx}. {str(op)}" for idx, op in enumerate(self.operators)])
        )


class LogicalPlan(Plan):

    def __init__(self, operators: List[LogicalOperator] = []):
        self.operators = operators

    @staticmethod
    def fromOpsAndSubPlan(ops: List[LogicalOperator], subPlan: LogicalPlan) -> LogicalPlan:
        # create copies of all logical operators
        copySubPlan = [op.copy() for op in subPlan.operators]
        copyOps = [op.copy() for op in ops]

        # construct full set of operators
        copySubPlan.extend(copyOps)
        fullOperators = copySubPlan
        # make input and output schemas internally consistent
        for idx, op in enumerate(fullOperators):
            # if this op is a filter, set its outputSchema equal to its inputSchema
            if isinstance(op, FilteredScan):
                op.outputSchema = op.inputSchema

            # set next op's inputSchema to be this op's outputSchema
            if idx + 1 < len(fullOperators):
                nextOp = fullOperators[idx + 1]
                nextOp.inputSchema = op.outputSchema

        # return the LogicalPlan
        return LogicalPlan(fullOperators)


class PhysicalPlan(Plan):

    def __init__(self, operators: List[PhysicalOperator]):
        self.operators = operators
        self.estimates = {
            "total_time": None,
            "total_cost": None,
            "quality": None,
        }

        self.stats = PlanStats()

    @staticmethod
    def fromOpsAndSubPlan(ops: List[PhysicalOperator], subPlan: PhysicalPlan) -> PhysicalPlan:
        # create copies of all logical operators
        copySubPlan = [op.copy() for op in subPlan.operators]
        copyOps = [op.copy() for op in ops]

        # construct full set of operators
        fullOperators = copySubPlan.extend(copyOps)

        # return the PhysicalPlan
        return PhysicalPlan(fullOperators)

    def __str__(self) -> str:
        """Computes a string representation for this plan."""
        # TODO
        physicalOps = physicalTree.dumpPhysicalTree()
        flat = flatten_nested_tuples(physicalOps)
        ops = [op for op in flat if not op.is_hardcoded()]
        label = "-".join([
            f"{repr(op.model)}_{op.query_strategy if isinstance(op, ConvertFromCandidateOp) else None}_{op.token_budget if isinstance(op, ConvertFromCandidateOp) else None}"
            for op in ops
        ])
        return f"PZ-{label_idx}-{label}"

    def getModels() -> List[Optional[str]]:
        """Return the list of models for each operator."""
        return []

    def getExecutionData() -> List[Dict[str, Any]]:
        """Compute and return all sample execution data collected by this plan so far."""
        # TODO
        return []

    def execute(self):
        """Execute the plan."""
        # TODO
        pass

    def estimateCost(self, sample_execution_data: Optional[Dict[str, Dict[str, Any]]]):
        """Estimate the runtime, cost, and quality of the plan."""
        totalTime = planCost["totalTime"]
        totalCost = planCost["totalUSD"]  # for now, cost == USD
        quality = planCost["quality"]

        plans.append((totalTime, totalCost, quality, physical_plan, fullPlanCostEst))

    def __iter__(self):
        """Iterate over source records from datasource."""
        # TODO
        base_operator = self.operators[-1]
        for record, stats in base_operator:
            self.stats.append(stats)
            yield record
