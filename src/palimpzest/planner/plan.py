from __future__ import annotations

from palimpzest.operators import LogicalOperator, FilteredScan
from palimpzest.operators.physical import PhysicalOp
from palimpzest.sets import Set

from typing import Any, Dict, List, Optional


class Plan:
    """A generic Plan is a graph of nodes (#TODO a list for now).
    The main subclasses are a LogicalPlan, which is composed of logical Operators, and a PhysicalPlan, which is composed of physical Operators.
    Plans are typically generated by objects of class Planner, and consumed by several objects, e.g., Execution, CostEstimator, Optimizer, etc. etc.
    """

    operators = []

    def __init__(self):
        raise NotImplementedError

    def __iter__(self):
        return iter(self.operators)

    def __next__(self):
        return next(iter(self.operators))
    
    def __len__(self):
        return len(self.operators)

    def __repr__(self):
        return f"{self.__class__.__name__}:\n" + "\n".join(
            map(str, [f"{idx}. {str(op)}" for idx, op in enumerate(self.operators)])
        )


class LogicalPlan(Plan):

    def __init__(self, operators: List[LogicalOperator] = []):
        self.operators = operators

    @staticmethod
    def fromOpsAndSubPlan(ops, subPlan) -> LogicalPlan:
        # create copies of all logical operators
        copySubPlan = [op.copy() for op in subPlan]
        copyOps = [op.copy() for op in ops]

        # set input schema of first new op to match output schema of last op in subplan
        copyOps[0].inputSchema = copySubPlan[-1].outputSchema

        # construct full set of operators
        fullOperators = copySubPlan.extend(copyOps)

        # make input and output schemas internally consistent
        for idx, op in enumerate(fullOperators):
            # if this op is a filter, set its outputSchema equal to its inputSchema
            if isinstance(op, FilteredScan):
                op.outputSchema = op.inputSchema

            # set next op's inputSchema to be this op's outputSchema
            if idx + 1 < len(fullOperators):
                nextOp = fullOperators[idx + 1]
                nextOp.inputSchema = op.outputSchema

        # return the LogicalPlan
        return LogicalPlan(fullOperators)


class PhysicalPlan(Plan):

    def __init__(self, num_samples):
        self.operators = []
        self.num_samples = num_samples

        self.stats = PlanStats()

    def __str__(self) -> str:
        """Computes a string representation for this plan."""
        # TODO
        physicalOps = physicalTree.dumpPhysicalTree()
        flat = flatten_nested_tuples(physicalOps)
        ops = [op for op in flat if not op.is_hardcoded()]
        label = "-".join([
            f"{repr(op.model)}_{op.query_strategy if isinstance(op, InduceFromCandidateOp) else None}_{op.token_budget if isinstance(op, InduceFromCandidateOp) else None}"
            for op in ops
        ])
        return f"PZ-{label_idx}-{label}"

    def getModels() -> List[Optional[str]]:
        """Return the list of models for each operator."""
        return []

    def getExecutionData() -> List[Dict[str, Any]]:
        """Compute and return all sample execution data collected by this plan so far."""
        # TODO
        return []

    def __iter__(self):
        """Iterate over source records from datasource."""
        # TODO
        base_operator = self.operators[-1]
        for record, stats in base_operator:
            self.stats.append(stats)
            yield record
        
